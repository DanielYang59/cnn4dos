

import numpy as np
import pandas as pd
from scipy import stats


def linear_fitting_without_mixing(adsorption_energies, group_x, group_y, descriptor_x, descriptor_y, verbose=True):
    """Perform individual linear fit for two groups of adsorbates.

    Args:
        adsorption_energies (dict): dict of adsorption energies
        group_x (list): group x adsorbates
        group_y (list): group y adsorbates
        descriptor_x (str): x-axis adsorbate
        descriptor_y (str): y-axis adsorbate
        verbose (bool, optional): print results during fitting. Defaults to True.

    Returns:
        tuple: (fit results of group_x, fit results of group_y)
                
    """
    # Check args
    assert isinstance(adsorption_energies, pd.DataFrame)  
    assert isinstance(group_x, list)
    assert isinstance(group_y, list)
    assert descriptor_x != descriptor_y
    assert isinstance(descriptor_x, str) and descriptor_x in group_x
    assert isinstance(descriptor_y, str) and descriptor_y in group_y
    assert not list(set(group_x).intersection(group_y))
    
    
    # Perform linear fitting for group x
    fitting_results_x = {}
    for ads in group_x:
        if ads != descriptor_x:
            result = stats.linregress(
                np.array(adsorption_energies[descriptor_x]), 
                np.array(adsorption_energies[ads])
                )  # slope, intercept, r_value, p_value, std_err
            
            fitting_results_x[f"{descriptor_x}_{ads}"] = result
            
            if verbose:
                print(f"R2 for {descriptor_x} vs {ads} is {result.rvalue}.")
    
    
    # Perform linear fitting for group y
    fitting_results_y = {}
    for ads in group_y:
        if ads != descriptor_y:
            result = stats.linregress(
                np.array(adsorption_energies[descriptor_y]), 
                np.array(adsorption_energies[ads])
                )
            
            fitting_results_y[f"{descriptor_y}_{ads}"] = result
            
            if verbose:
                print(f"R2 for {descriptor_y} vs {ads} is {result.rvalue}.")
        
    
    return (fitting_results_x, fitting_results_y)
    

def linear_fitting_with_mixing(adsorption_energies, descriptor_x, descriptor_y, verbose=True):
    """Perform linear fitting of selected TWO descriptors with automatic mixing.

    Args:
        adsorption_energies (pd.DataFrame): adsorbate energies datasheet
        descriptor_x (str): selected descriptor for x-axis
        descriptor_y (str): selected descriptor for y-axis
        verbose (bool, optional): verbose. Defaults to True.

    Notes:
        For fitting of CO2 adsorption energy, assuming two descriptors are CO and OH.
        
        First Stage - Mixing Percentage Test:
            A hybrid descriptor would be generated by mixing two descriptors, 
            Ehybrid = a * EadsCO + (1 - a) * EadsOH, where "a" is the percentage of EadsCO in range (0, 1).
            Then the script would loop through 0% to 100% to find the best mixing percentage.
            
        Second Stage - Fitting and Output:
            Assume b is the best mixing percentage, a best hybrid descriptor would first be compiled,
            where Ehybrid = b * EadsCO + (1 - b) * EadsOH.
            
            Then a linear fitting with the target adsorption EadsCO2 would be performed, 
            resulting in EadsCO2 = slope * Ehybrid + intercept.
            
            Finally the hybrid descriptor would be unpack, EadsCO2 = slope * (b * EadsCO + (1 - b) * EadsOH) + intercept,
            which then reduce to slope * b * EadsCO + slope * (1 - b) * EadsOH + intercept.
            
            The final output of this function would be [para_a, para_b, para_c], where
                para_a = slope * b
                para_b = slope * (1 - b)
                para_c = intercept

    Returns:
        dict: relation-parameter pairs, where key is adsorbate name and value is parameter in [para_a, para_b, para_constant].
        
    """
    # Check args
    assert isinstance(adsorption_energies, pd.DataFrame)
    assert descriptor_x != descriptor_y
    assert isinstance(descriptor_x, str)
    assert isinstance(descriptor_y, str)
    
    
    # Loop through adsorbates
    fitting_results = {}
    for ads in list(adsorption_energies.columns.values):
        if ads not in [descriptor_x, descriptor_y]:
            
            # Test mixing percentage
            percentage_dict = {}
            for percentage in range(101):
                # Compile x array
                x_array = np.array(adsorption_energies[descriptor_x]) * percentage * 0.01 + \
                    np.array(adsorption_energies[descriptor_y]) * (100 - percentage) * 0.01
                
                # Perform linear fitting
                result = stats.linregress(
                    x_array, 
                    np.array(adsorption_energies[ads]))
                
                percentage_dict[percentage] = result
                
                if verbose:
                    print(f"Adsorbate: {ads}, {descriptor_x} {percentage} %, {descriptor_y} {100 - percentage} %, r2: {round(result.rvalue, 6)}.")
                    
            
            # Get best and worst percentage
            r2values = [i.rvalue for i in percentage_dict.values()]
            best_r2 = max(r2values)
            best_percentage = r2values.index(best_r2)
            
            if verbose: 
                print(f"Best R2 for {ads} is {round(best_r2, 4)}, {descriptor_x} {best_percentage} %. Worst R2 for {ads} is {round(min(r2values), 4)}, {descriptor_x} {r2values.index(min(r2values))} %.")
          

            # Perform fitting with best descriptor percentage
            x_array = np.array(adsorption_energies[descriptor_x]) * best_percentage * 0.01 + \
                    np.array(adsorption_energies[descriptor_y]) * (100 - best_percentage) * 0.01
                
            result = stats.linregress(
                x_array, 
                np.array(adsorption_energies[ads]))
            
            
            # Convert fitting results into parameters
            para_a = result.slope * best_percentage * 0.01
            para_b = result.slope * (1 - best_percentage) * 0.01
            para_c = result.intercept
            
            fitting_results[ads.split("-")[-1]] = np.array([para_a, para_b, para_c])
        
    
    # Add descriptor relations
    fitting_results[descriptor_x.split("-")[-1]] = np.array([1, 0, 0])
    fitting_results[descriptor_y.split("-")[-1]] = np.array([0, 1, 0])

                
    return fitting_results
   
    
# Test area
if __name__ == "__main__":
    # Load adsorption energy
    from energy_loader import energyLoader, stack_diff_sub_energy_dict
    path = "../../0-dataset/label_adsorption_energy"
    substrates = ["g-C3N4_is", "nitrogen-graphene_is", "vacant-graphene_is", "C2N_is", "BN_is", "BP_is"]
    adsorbates = ["1-CO2", "2-COOH", "3-CO", "4-OCH", "5-OCH2", "6-OCH3", "7-O", "8-OH", "11-H"]
    loader = energyLoader()
    loader.load_adsorption_energy(path, substrates, adsorbates)
    adsorption_energies = stack_diff_sub_energy_dict(loader.adsorption_energy_dict)

    
    # Test fitting
    group_x = ["1-CO2", "2-COOH", "3-CO"]
    descriptor_x = "3-CO"
    group_y = ["4-OCH", "5-OCH2", "6-OCH3", "7-O", "8-OH", "11-H"]
    descriptor_y = "8-OH"
    
    # linear_fitting_without_mixing(adsorption_energies, group_x, group_y, descriptor_x, descriptor_y)
    fitting_results = linear_fitting_with_mixing(adsorption_energies, descriptor_x, descriptor_y, verbose=False)
    print(fitting_results)
    